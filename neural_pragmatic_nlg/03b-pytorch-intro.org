#+title:     Sheet 2.1: PyTorch essentials
#+author:    Michael Franke

This work sheet introduces the very basics of PyTorch.
If you want to install PyTorch locally on your machine, follow [[https://pytorch.org/get-started/locally/][these instructions]].
If installed, import the library to make it usable:

#+begin_src jupyter-python
import torch
#+end_src

* Tensors

Tensors are the default data structure used for the representation of
numbers in PyTorch. In mathematics (algebra), a tensor is a
generalization of the concept of a matrix. For our purposes, let's think
of a tensor as basically an \(n\)-dimensional array of numbers.

For example, a single scalar (a single number) is a zero-dimensional
array. An \(n\)-dimensional vector is a one-dimensional array of \(n\)
numbers. An \(n \times m\) matrix is a two-dimensional array with \(n\)
rows and \(m\) columns. All of these -scalars, vectors and matrices- are
tensors. But /tensors also include even more high-dimensional objects/.
For instance, an \(k \times n \times m\) tensor is a three-dimensional
array, which includes \(k\) matrices, each of which has \(n\) rows and
\(m\) columns. And so on.

Full documetation for torch.Tensor class:
[[https://pytorch.org/docs/stable/tensors.html]]

#+ATTR_ORG: :width 500
#+ATTR_HTML: :width 500px
#+ATTR_LATEX: :width 500px
#+ATTR_JUPYTER: :width 500px
[[./pics/03-scalars-vectors-matrices-tensors.png]]


> <strong><span style="color:#D83D2B;">Exercise 1: Dimensions of tensors</span></strong>
>
> What are the dimensions of the following tensors?
>
> 1. $1$
> 2. $[1,2,3]$
> 3. $[[1,2], [3,4]]$
> 4. $[[1,2], [3,4], [5,6]]$
> 5. $[[[1,2], [3,4], [5,6]]]$


* Creating a tensor

There are various ways to create a tensor in PyTorch.
We will go through a few examples here.

Tensors can be initialised from a list:

#+begin_src jupyter-python
a_list = [1, 2, 3, 4]
tensor_from_list = torch.tensor(a_list)
tensor_from_list
#+end_src

Or directly:

#+begin_src jupyter-python
new_tensor = torch.tensor([1, 2, 3, 4])
new_tensor
#+end_src

Tensor construction will replicate shape and dimensionality of the data
passed to it:

#+begin_src jupyter-python
tensor_0d = torch.tensor(1)
tensor_0d
#+end_src

#+RESULTS:
: tensor(1)

#+begin_src jupyter-python
tensor_2d = torch.tensor([[1,2,3],[4,5,6]])
tensor_2d
#+end_src

#+RESULTS:
: tensor([[1, 2, 3],
:         [4, 5, 6]])

Tensors can also be constructed from numpy arrays:

#+begin_src jupyter-python
import numpy as np

np_array = np.zeros((2,2))
np_array_to_tensor = torch.tensor(np_array)
np_array_to_tensor
#+end_src

#+RESULTS:
: tensor([[0., 0.],
:         [0., 0.]], dtype=torch.float64)

Or with build-in torch functionality:

#+begin_src jupyter-python
zeros = torch.zeros((2,2))
zeros
#+end_src

#+begin_src jupyter-python
ones = torch.ones((2,3))
ones
#+end_src

#+begin_src jupyter-python
filled = torch.full((4,3), 5)
filled
#+end_src

* Tensor data types

Tensor-supported data types are:
- numeric: float, int
- boolean
- complex numbers

All the values in the same tensor are of the same data type.

#+begin_src jupyter-python
true = torch.tensor([True, True])
true
#+end_src

#+RESULTS:
: tensor([True, True])

#+begin_src jupyter-python
true.dtype
#+end_src

#+RESULTS:
: torch.bool

#+begin_src jupyter-python
true = torch.tensor([True, 1])
true
#+end_src

#+RESULTS:
: tensor([1, 1])

#+begin_src jupyter-python
true.dtype
#+end_src

#+RESULTS:
: torch.int64

What about strings? PyTorch tensors have no character or string data
type support.

#+begin_src jupyter-python
hello        = 'Hello World!'
hello_tensor = torch.tensor([ord(char) for char in hello])
hello_tensor
#+end_src

#+RESULTS:
: tensor([ 72, 101, 108, 108, 111,  32,  87, 111, 114, 108, 100,  33])

* Attributes of a tensor

Tensors have attributes, which store information about some of their important properties.
Here are some important examples:

#+begin_src jupyter-python
print(f"Shape of tensor: {hello_tensor.shape}")
print(f"Datatype of tensor: {hello_tensor.dtype}")
print(f"Device tensor is stored on: {hello_tensor.device}")
#+end_src

#+RESULTS:
: Shape of tensor: torch.Size([12])
: Datatype of tensor: torch.int64
: Device tensor is stored on: cpu

The latter property assessed with `.device` tells us where the tensor is stored and manipulated.
The default is the CPU.
If your machine allows you can also shift all your tensors to a GPU.
The syntax for doing this is slightly different on different machines.

* Operations on tensors

** Slicing and indexing

The same slicing method used on arrays and numpy arrays can be used on
tensors as well. The returned result will also be a tensor.

#+begin_src jupyter-python
bigger_tensor = torch.tensor([[1,2,3],[4,5,6],[7,8,9],[10,11,12]])
first_row     = bigger_tensor[0]
last_row      = bigger_tensor[3]
first_row
#+end_src

#+RESULTS:
: tensor([1, 2, 3])

#+begin_src jupyter-python
first_column = bigger_tensor[:,0]
first_column
#+end_src

#+RESULTS:
: tensor([ 1,  4,  7, 10])

** Joining tensors

#+begin_src jupyter-python
head_and_tail = torch.cat([first_row, last_row])
head_and_tail
#+end_src

#+RESULTS:
: tensor([ 1,  2,  3, 10, 11, 12])

What if we want to add a dimension?

#+begin_src jupyter-python
head_and_tail = torch.stack([first_row, last_row])
head_and_tail
#+end_src

#+RESULTS:
: tensor([[ 1,  2,  3],
:         [10, 11, 12]])

** Assessing just the values of a tensor

Accessing a single value output with indices:

#+begin_src jupyter-python
value = bigger_tensor[1][2]
value
#+end_src

#+RESULTS:
: tensor(6)

The `tensor.item()` function returns the value of a single-item tensor without any further information, which is often useful for inspection or plotting of results:

#+begin_src jupyter-python
value.item()
#+end_src

#+RESULTS:
: 6

To convert a larger tensor back to numpy (e.g., for plotting) you can do this:

#+begin_src jupyter-python
another_tensor = torch.tensor([[1,2,3], [4,5,6]])
another_tensor.detach().numpy()
#+end_src

#+RESULTS:
: array([[1, 2, 3],
:        [4, 5, 6]])

** Reshaping

The function `torch.reshape()` is a frequently used way of returning a tensor in the
specified shape.
Its input are the desired output dimensions.
NB: the reshaping returns a new tensor and does not modify the old tensor.

#+begin_src jupyter-python
tensor_1 = torch.tensor([[1, 2], [3, 4]])
tensor_2 = tensor_1.reshape(4, 1)
print(tensor_1)
print(tensor_2)
#+end_src

#+RESULTS:
: tensor([[1, 2],
:         [3, 4]])
: tensor([[1],
:         [2],
:         [3],
:         [4]])

#+begin_src jupyter-python
a = torch.tensor([[0, 1], [2, 3]])
b = torch.reshape(a, (-1,))
print(a)
print(b)
#+end_src

#+RESULTS:
: tensor([[0, 1],
:         [2, 3]])
: tensor([0, 1, 2, 3])

** Transposing

It is possible to transpose a tensor by specified dimesions using the
function: `torch.transpose()`,
This function takes the dimensions which are to be transposed as an argument.

#+begin_src jupyter-python
tensor_1 = torch.tensor([[[10, 20, 30], [40, 50, 60], [70, 80, 90]],
                         [[1,2,3],[4,5,6],[7,8,9]] ])
tensor_1_transpose = torch.transpose(tensor_1, 1, 2)
print(tensor_1)
print(tensor_1_transpose)
#+end_src

#+RESULTS:
#+begin_example
tensor([[[10, 20, 30],
         [40, 50, 60],
         [70, 80, 90]],

        [[ 1,  2,  3],
         [ 4,  5,  6],
         [ 7,  8,  9]]])
tensor([[[10, 40, 70],
         [20, 50, 80],
         [30, 60, 90]],

        [[ 1,  4,  7],
         [ 2,  5,  8],
         [ 3,  6,  9]]])
#+end_example

** Matrix Multiplication

To perform a matrix multiplications on tensors, we use the function
`torch.mm(tensor1, tensor2)`.

If `tensor1` is an $(n×m)$ tensor, and `tensor2` is an $(m×p)$ tensor, the
output will be an $(n×p)$ tensor.

#+begin_src jupyter-python
tensor_1 = torch.tensor([[1, 2], [3, 4], [5, 6]])
tensor_2 = torch.tensor([[10, 0], [1, 100]])
product = torch.mm(tensor_1, tensor_2)
print(product)
#+end_src

#+RESULTS:
: tensor([[ 12, 200],
:         [ 34, 400],
:         [ 56, 600]])

** Tensor arithmetic

A one-dimensional tensor is a row-vector:

#+begin_src jupyter-python
row_vector = torch.tensor([1,10,100])
print(row_vector)
#+end_src

#+RESULTS:
: tensor([  1,  10, 100])

With the usual arithmetic operations, a row vector will be recycled in the obvious way:

#+begin_src jupyter-python
row_vector = torch.tensor([1,10])
matrix     = torch.tensor([[1,2], [3,4]])
print("multiplication:\n", matrix * row_vector)
#+end_src

#+RESULTS:
: multiplication:
:  tensor([[ 1, 20],
:         [ 3, 40]])

#+begin_src jupyter-python
print("division:\n" , matrix / row_vector)
#+end_src


#+RESULTS:
: division:
:  tensor([[1.0000, 0.2000],
:         [3.0000, 0.4000]])

#+begin_src jupyter-python
print("addition:\n"    , matrix + row_vector)
print("subtraction:\n" , matrix - row_vector)
#+end_src

#+RESULTS:
: addition:
:  tensor([[ 2, 12],
:         [ 4, 14]])
: subtraction:
:  tensor([[ 0, -8],
:         [ 2, -6]])
